<!DOCTYPE html>
<html lang="en">
<head>
    <title>Structures, Sorting and Such</title>
    <!-- code below used for bootstrap -->
	<meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">  <!-- viewport is the users screen, and the 2 settings used here is the width of screen of device and initial scale means don't zoom in or out just 100% -->
    
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>  <!-- standard jquery library --> 
	
	<!-- Latest compiled and minified CSS -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

	<!-- Optional theme -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

	<!-- Latest compiled and minified JavaScript -->
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
	
	<!-- code above used for bootstrap --> 
	<link rel ="stylesheet" href = "style.css" type = "text/css">
</head>
<body>

	<!-- navigation bar in bootstrap --> 
	
	<nav class="navbar navbar-inverse">  <!-- navbar-default is the styling of the navbar --> 
		<div class="container-fluid">
		
			<!-- Logo Below --> 
			<div class="navbar-header"> <!-- this lets bootstrap know that this isnt an actual button but just a logo --> 
				<a href="index.html" class="navbar-brand">Home</a>  <!-- you could link this to the homepage but the # is used for a dead link --> 
			</div>
			
			<!-- Menu Items Below -->
			<div>
				<ul class="nav navbar-nav">
					
					<!-- Drop down menu, this will be in the list at top but itself will contain another list -->
					<li class="dropdown">
						<a href="#" class="dropdown-toggle" data-toggle="dropdown">Data Structures <span class="caret"></span></a>  <!-- this is the "link" with a down arrow the user can click on to see the other menu items in the dropdown list -->
						<ul class="dropdown-menu"> <!-- dropdown menu items --> 
							<li><a href="structures-overview.html">Overview of Data Structures</a></li>
							<li><a href="array-Bag.html">Array - Bag ADT</a></li>
							<li><a href="array-Stack.html">Array - Stack ADT</a></li>
							<li><a href="dynamicArray-Bag.html">Dynamic Array - Bag ADT</a></li>
							<li><a href="dynamicArray-Stack.html">Dynamic Array - Stack ADT</a></li>
						</ul>
					</li>
					
					<li class="dropdown">
						<a href="#" class="dropdown-toggle" data-toggle="dropdown">Sorting Algorithms <span class="caret"></span></a>  <!-- this is the "link" with a down arrow the user can click on to see the other menu items in the dropdown list -->
						<ul class="dropdown-menu"> <!-- dropdown menu items --> 
							<li><a href="sorting-overview.html">Overview of Sorting Algorithms</a></li>
							<li><a href="#">Bubble Sort</a></li>
							<li><a href="#">Merge Sort</a></li>
						</ul>
					</li>
					
					<li class="dropdown">
						<a href="#" class="dropdown-toggle" data-toggle="dropdown">Misc. Algorithms <span class="caret"></span></a>  <!-- this is the "link" with a down arrow the user can click on to see the other menu items in the dropdown list -->
						<ul class="dropdown-menu"> <!-- dropdown menu items --> 
							<li><a href="misc-overview.html">Overview of misc. algorithms</a></li>
							<li><a href="binarySearch.html">Binary Search</a></li>
						</ul>
					</li>
					
				</ul>
				
				<!-- right align menu items -->
				<ul class="nav navbar-nav navbar-right">
					<li><a href="aboutMe.html">About Me</a></li>
				</ul>
				
			</div>
		
		</div>
	</nav>
	
	<!-- Main Content (below navigation bar) -->
	<div class="container">     <!-- class=container-fluid is full screen, class=container is just a fixed width --> 
		
		<!-- <center><img src="images/underConstruction.jpg"></center><br> -->
		<h1 class="title">Dynamic Array implementation of the Bag (ADT)</h1>
		<!-- a well is a "floating island" that has a boarder and a grey background -->
		<div class="well">
			
			<p>
				A dynamic array is also called a Vector (in C++) or ArrayList (in Java) and is a little different than just an array. 
				Using a dynamic array to implement a Bag or Stack ADT instead of just an array, takes away the size limitation that the array has. A dynamic array 
				uses an array as the underlying data structure but it now dynamically increases in size during run time as necessary. Therefore, unlike just an array, 
				a dynamic array can change its capacity. When refering to dynamic arrays it should be noted the difference between size and capacity. Size is the 
				logical collection size, or the current number of elements in the dynamic array. Capacity is the physical array size, or the number of elements it 
				can hold before it must resize. <br><br>
				
				When the dynamic array size reaches the dynamic array capacity, then a new (larger) data array must be allocated. It is common for this newly reallocated array 
				to be twice the capacity as the initial array. Once this new array is allocated, then the initial array contents are copied over and the initial array is then 
				deallocated. You are then left with a new array with the same elements in the same order in it, but now there is a lot more room remaining for additional values 
				to be added. In this case, the big O complexity is O(n). <br><br>
				
				Below is the interface file (dynArrADT.h) and the implementation file (dynArrADT.c) for the dynamic array implementation of the Bag ADT<br><br>
				
				<b>dynArrADT.h</b><br>
				<pre>
# ifndef dynArrADT
# define dynArrADT

# define TYPE int 

struct DynArr {
	TYPE * data;
	int size;
	int capacity;
};

void initDynArr(struct DynArr *v, int capacity);
void freeDynArr(struct DynArr *v);
int sizeDynArr(struct DynArr *v);
void addDynArr(struct DynArr *v, TYPE val);
TYPE getDynArr(struct DynArr *v, int position);
void putDynArr(struct DynArr *v, int position, TYPE value);
void removeAtDynArr(struct DynArr *v, int position);
void swapDynArr(struct DynArr *v, int i, int j);

void removeDynArr(struct DynArr *v, TYPE value);
int containsDynArr(struct DynArr *v, TYPE value);

# endif</pre><br>

			<b>dynArrADT.c</b><br>
			<pre>
#include "dynArrADT.h"
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

struct DynArr {
	TYPE * data;
	int size;
	int capacity;
};

struct DynArr * createDynArr()
{
	struct DynArr * v = malloc(sizeof(struct DynArr));
	
	return v; 
}


void initDynArr(struct DynArr *v, int capacity)
{
	v->data = malloc(sizeof(TYPE) * capacity);
	
	v->size = 0;
	v->capacity = capacity;
}


void freeDynArr(struct DynArr *v)
{
	if (v->data != 0)
	{
		free(v->data);
		v->data = 0;
	}
	v->size = 0;
	v->capacity = 0;
}


int sizeDynArr(struct DynArr *v)
{
	return v->size; 
}


void _setCapacityDynArr(struct DynArr *v, int newCap)
{
	int i;
	
	TYPE *newData = malloc(sizeof(TYPE) * newCap);
	
	for (i = 0; i < v->capacity; i++)
	{
		newData[i] = v->data[i]; 
	}
	
	free(v->data);
	
	v->data = newData;
	v->capacity = newCap; 
}


void addDynArr(struct DynArr *v, TYPE val)
{
	if (v->size >= v->capacity)
		_setCapacityDynArr(v, v->capacity * 2);
		
	v->data[v->size] = val;
	
	v->size++; 
}


TYPE getDynArr(struct DynArr *v, int position)
{
	assert((position >= 0) && (position < v->size));
	
	return v->data[position]; 
}


void putDynArr(struct DynArr *v, int position, TYPE value)
{
	assert((position >= 0) && (position < v->size));
	
	v->data[position] = value;
}


void removeAtDynArr(struct DynArr *v, int position)
{
	assert((position >= 0) && (position < v->size));
	
	while (position < v->size - 1)
	{
		v->data[position] = v->data[position + 1];
		position++;
	}
	
	v->size--;
}


void swapDynArr(struct DynArr *v, int i, int j)
{
	assert((i >= 0) && (i < v->size));
	assert((j >= 0) && (j < v->size)); 
	
	TYPE temp;
	
	temp = v->data[i];
	v->data[i] = v->data[j];
	v->data[j] = temp;
}


void removeDynArr(struct DynArr *v, TYPE value)
{
	int i;
	
	for (i = 0; i < v->size; i++)
	{
		if (v->data[i] == value)
		{
			removeAtDynArr(v, value);
			return; 
		}	
	}
}


int containsDynArr(struct DynArr *v, TYPE value)
{
	int i;
	
	for (i = 0; i < v->size; i++)
	{
		if (v->data[i] == value)
			return 1;
	}
	return 0; 
}</pre>
			</p>
			
		</div>
		
		<center>&copy Peter Moldenhauer April 7th 2017 ~ moldenhp@oregonstate.edu</center><br> 
		
	</div>
	
</body>
</html>